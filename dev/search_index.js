var documenterSearchIndex = {"docs":
[{"location":"#TenSolver.jl","page":"TenSolver.jl","title":"TenSolver.jl","text":"","category":"section"},{"location":"","page":"TenSolver.jl","title":"TenSolver.jl","text":"Documentation for TenSolver.jl","category":"page"},{"location":"","page":"TenSolver.jl","title":"TenSolver.jl","text":"Modules = [TenSolver]","category":"page"},{"location":"#Base.in-Tuple{Any, TenSolver.Distribution}","page":"TenSolver.jl","title":"Base.in","text":"in(xs, psi::Distribution [; cutoff)\n\nWhether the vector xs has a positive probability of being sampleable from psi. When setting cutoff, it will be used as the minimum probability considered positive.\n\n\n\n\n\n","category":"method"},{"location":"#TenSolver.maximize-Tuple","page":"TenSolver.jl","title":"TenSolver.maximize","text":"maximize(Q::Matrix[, l::Vector[, c::Number; kwargs...)\n\nSolve the Quadratic Unconstrained Binary Optimization problem for maximization.\n\nmax  b'Qb + l'b + c\ns.t. b_i in {0, 1}\n\nSee also minimize.\n\n\n\n\n\n","category":"method"},{"location":"#TenSolver.minimize-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Union{Nothing, AbstractVector{T}}}, Tuple{AbstractMatrix{T}, Union{Nothing, AbstractVector{T}}, T}} where T","page":"TenSolver.jl","title":"TenSolver.minimize","text":"minimize(Q::Matrix[, l::Vector[, c::Number ; device, cutoff, kwargs...)\n\nSolve the Quadratic Unconstrained Binary Optimization (QUBO) problem\n\nmin  b'Qb + l'b + c\ns.t. b_i in {0, 1}\n\nReturn the optimal value E and a probability distribution ψ over optimal solutions. You can use sample to get an actual bitstring solving the QUBO.\n\nThis function uses DMRG with tensor networks to calculate the optimal solution, by finding the ground state (least eigenspace) of the Hamiltonian\n\nH = Σ Q_ij D_iD_j + Σ l_i D_i\n\nwhere D_i acts locally on the i-th qubit as [0 0; 0 1], i.e, the projection on |1>.\n\nThe optional keyword device controls whether the solver should run on CPU or GPU. For using a GPU, you can import the respective package, e.g. CUDA.jl, and pass its accelerator as argument.\n\nimport CUDA\nminimize(Q; device = CUDA.cu)\n\nimport Metal\nminimize(Q; device = Metal.mtl)\n\nSee also maximize.\n\n\n\n\n\n","category":"method"},{"location":"#TenSolver.minimize-Union{Tuple{T}, Tuple{AbstractMatrix{T}, T}} where T","page":"TenSolver.jl","title":"TenSolver.minimize","text":"minimize(Q::Matrix, c::Number; kwargs...)\n\nSolve the Quadratic Unconstrained Binary Optimization problem with no linear term.\n\nmin  b'Qb + c\ns.t. b_i in {0, 1}\n\nSee also maximize.\n\n\n\n\n\n","category":"method"},{"location":"#TenSolver.sample-Tuple{TenSolver.Distribution}","page":"TenSolver.jl","title":"TenSolver.sample","text":"sample(psi)\n\nSample a bitstring from a (quantum) probability distribution.\n\n\n\n\n\n","category":"method"},{"location":"#TenSolver.tensorize","page":"TenSolver.jl","title":"TenSolver.tensorize","text":"tensorize(sites, p::AbstractArray{T, n})\n\nTurn a quadratic/linear function acting on bitstrings into an equivalent MPO Hamiltonian acting on Qudit sites. The conversion consists of exchanging each integer variable x_i for a matrix P_i whose eigenvalues represent its feasible set K_i.\n\n∑ Q_ij x_i x_j + ∑ l_i x_i --> H = Σ Q_ij D_i D_j + ∑ l_i D_i\n\n\n\n\n\n","category":"function"}]
}
