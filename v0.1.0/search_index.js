var documenterSearchIndex = {"docs":
[{"location":"#TenSolver.jl","page":"TenSolver.jl","title":"TenSolver.jl","text":"","category":"section"},{"location":"","page":"TenSolver.jl","title":"TenSolver.jl","text":"Documentation for TenSolver.jl","category":"page"},{"location":"#Base.in-Tuple{Any, TenSolver.Distribution}","page":"TenSolver.jl","title":"Base.in","text":"in(xs, psi::Distribution [; cutoff)\n\nWhether the vector xs has a positive probability of being sampleable from psi. When setting cutoff, it will be used as the minimum probability considered positive.\n\n\n\n\n\n","category":"method"},{"location":"#TenSolver.maximize-Tuple","page":"TenSolver.jl","title":"TenSolver.maximize","text":"maximize(Q::Matrix[, l::Vector[, c::Number; kwargs...)\n\nSolve the Quadratic Unconstrained Binary Optimization problem for maximization.\n\nmax  b'Qb + l'b + c\ns.t. b_i in {0, 1}\n\nSee also minimize.\n\n\n\n\n\n","category":"method"},{"location":"#TenSolver.minimize-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Union{Nothing, AbstractVector{T}}}, Tuple{AbstractMatrix{T}, Union{Nothing, AbstractVector{T}}, T}} where T","page":"TenSolver.jl","title":"TenSolver.minimize","text":"minimize(Q::Matrix[, l::Vector[, c::Number ; device, cutoff, kwargs...)\n\nSolve the Quadratic Unconstrained Binary Optimization (QUBO) problem\n\nmin  b'Qb + l'b + c\ns.t. b_i in {0, 1}\n\nReturn the optimal value E and a probability distribution ψ over optimal solutions. You can use sample to get an actual bitstring from ψ.\n\nThis function uses DMRG with tensor networks to calculate the optimal solution, by finding the ground state (least eigenspace) of the Hamiltonian\n\nH = Σ Q_ij D_iD_j + Σ l_i D_i\n\nwhere D_i acts locally on the i-th qubit as [0 0; 0 1], i.e, the projection on |1>.\n\nKeyword arguments:\n\niterations :: Int - Maximum iterations the solver should run. Defaults to 10.\ncutoff :: Float64 - Any absolute value below this threshold is considered zero. Defaults to 1e-8. You can use this keyword to control the solver's accuracy vs resources trade-off.\nmaxdim - The maximum allowed bond dimension. Integer or array of integer specifying the bond dimension per iteration. You can use this keyword to control the solver's accuracy vs resources trade-off.\nmindim - The minimum allowed bond dimension, if possible. Integer or array of integer specifying the bond dimension per iteration.\ntime_limit :: Float64 - If specified, determines the maximum running time in seconds. It only determines whether a new iteration should start or not, thus the solver may run for longer if the threshold happens during an iteration.\ndevice = cpu - Accelerator device used during computation. See the section below for how to run on GPUs.\nvtol :: Float64 - If specified, determines the variance tolerance before the algorithm stops. The variance test determines whether DMRG converged to an eigenstate (not necessarily the ground state), but is expensive to calculate.\nnoise - A float or array of floats (per iteration) specifying the noise term added to the system to help with convergence. It is recommended to use a large noise (~ 1e-5) on the initial iterations and let it go to zero on later iterations.\neigsolve_krylovdim :: Int = 3 - Maximum Krylov space dimension used in the local eigensolver.\neigsolve_tol :: Float64 = 1e-14 - Eigensolver tolerance.\neigsolve_maxiter :: Int = 1 - Maximum iterations for eigensolver.\n\nRunning on GPU:\n\nThe optional keyword device controls whether the solver should run on CPU or GPU. For using a GPU, you can import the respective package, e.g. CUDA.jl, and pass its accelerator as argument.\n\nimport CUDA\nminimize(Q; device = CUDA.cu)\n\nimport Metal\nminimize(Q; device = Metal.mtl)\n\nSee also maximize.\n\n\n\n\n\n","category":"method"},{"location":"#TenSolver.minimize-Union{Tuple{T}, Tuple{AbstractMatrix{T}, T}} where T","page":"TenSolver.jl","title":"TenSolver.minimize","text":"minimize(Q::Matrix, c::Number; kwargs...)\n\nSolve the Quadratic Unconstrained Binary Optimization problem with no linear term.\n\nmin  b'Qb + c\ns.t. b_i in {0, 1}\n\nSee also maximize.\n\n\n\n\n\n","category":"method"},{"location":"#TenSolver.sample-Tuple{TenSolver.Distribution}","page":"TenSolver.jl","title":"TenSolver.sample","text":"sample(psi)\n\nSample a bitstring from a (quantum) probability distribution.\n\n\n\n\n\n","category":"method"},{"location":"#TenSolver.tensorize","page":"TenSolver.jl","title":"TenSolver.tensorize","text":"tensorize(sites, p::AbstractArray{T, n})\n\nTurn a quadratic/linear function acting on bitstrings into an equivalent MPO Hamiltonian acting on Qudit sites. The conversion consists of exchanging each integer variable x_i for a matrix P_i whose eigenvalues represent its feasible set K_i.\n\n∑ Q_ij x_i x_j + ∑ l_i x_i --> H = Σ Q_ij D_i D_j + ∑ l_i D_i\n\n\n\n\n\n","category":"function"}]
}
